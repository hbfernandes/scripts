#!/usr/bin/env groovy
import groovy.transform.Field

import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import javax.xml.bind.DatatypeConverter
import java.security.MessageDigest

// Compares 2 zips, 2 directories, a directory and a jar or 2 directories of zips

if(args.size() < 2){
  println 'usage: compare <options> leftFile rightFile'
  println 'options:'
  println '  -e: expand archives in the base directory to compare'
  println '  -h: perform hash comparison'
  System.exit(0)
}

excludes = ['pom.properties']

File left, right
@Field String options = ''

if(args.size() == 2) {
  left = new File(args[0])
  right = new File(args[1])
}
else{
  options = args[0] - '-'
  left = new File(args[1])
  right = new File(args[2])
}

if(left.directory && right.directory && options.contains('e')){
  left.listFiles().each { File file ->
    println "Comparing ${file.name}..."

    File subLeft = file
    File subRight = new File(right, subLeft.name)

    if(!subRight.exists()){
      println 'Missing on the right!'
      println '\n'
      return
    }

    compare(collect(subLeft), collect(subRight) )
    println '\n'
  }
}
else {
  compare(collect(left), collect(right))
}

void compare(Map leftData, Map rightData){
  boolean different = false

  leftData.each { k, v ->
    if(!rightData[k]){
      different = true
      println "-- ${k}"
    }
    else if(excludes.every { !k.endsWith(it) } && rightData[k] != v ){
      different = true
      println "!= ${k}"
    }
  }

  rightData.each { k, v ->
    if(!leftData[k]){
      different = true
      println "++ ${k}"
    }
  }

  if(!different){
    println "No differences."
  }
}

Map collect(File root){
  Map data = [:]
  String key

  if(root.directory){
    root.eachFileRecurse { File subfile ->
      key = subfile.canonicalPath - (root.canonicalPath + '/')

      data << [(key): subfile.directory ? 'd' : collectData(subfile.newInputStream())]
    }
  }
  else if(['.jar', '.zip', '.kar'].any{ root.name.endsWith(it) }){
    // zip files
    ZipFile zip = new ZipFile(root)
    zip.entries().each { ZipEntry entry ->
      key = entry.directory ? entry.name[0..-2] : entry.name

      data << [(key): entry.directory ? 'd' : collectData(zip.getInputStream(entry))]
    }
  }
  else {
    // whatever file
    key = root.canonicalPath - (root.parentFile.canonicalPath + '/')

    data << [(key): collectData(root.newInputStream())]
  }

  data
}

String collectData(InputStream stream) {
  if(!options.contains('h')){
    return '0'
  }

  MessageDigest md = MessageDigest.getInstance("SHA")
  md.update(stream.bytes)
  stream.close()

  DatatypeConverter.printHexBinary(md.digest())
}



